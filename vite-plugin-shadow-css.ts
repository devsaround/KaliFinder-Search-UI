import type { Plugin } from 'vite';

/**
 * Vite plugin to bundle processed CSS as an exportable string for Shadow DOM injection
 * This ensures Tailwind CSS is fully processed before being embedded
 */
export function shadowCssPlugin(): Plugin {
  let cssCode = '';
  const PLACEHOLDER = '__INLINED_WIDGET_CSS_PLACEHOLDER__';
  const sawRawCss = false; // track index.css imported as ?raw or ?inline

  return {
    name: 'vite-plugin-shadow-css',
    enforce: 'post', // Run after other plugins process CSS so TS/JS stays valid

    // Capture CSS generated by Tailwind and other processors
    generateBundle(options, bundle) {
      let cssAssetFound = false;

      // Find CSS assets in the bundle
      for (const [fileName, chunk] of Object.entries(bundle)) {
        if (fileName.endsWith('.css') && chunk.type === 'asset') {
          cssCode = chunk.source.toString();
          console.log(`[shadowCssPlugin] Captured ${cssCode.length} bytes of CSS from ${fileName}`);
          // Remove the CSS file from output since we'll inline it
          delete bundle[fileName];
          cssAssetFound = true;
        }
      }

      // If no CSS assets and we didn't see ?raw, warn; otherwise log and continue
      if (!cssAssetFound && !sawRawCss) {
        console.warn(
          '[shadowCssPlugin] No CSS found in bundle - styles may not work in Shadow DOM'
        );
        return;
      } else if (sawRawCss) {
        console.log('[shadowCssPlugin] CSS inlined via ?raw â€” skipping asset warning');
      }

      // Only try to inline if we found CSS assets
      if (cssCode) {
        // Inline CSS into the UMD bundle by prepending variable declaration
        const inlinedCss = JSON.stringify(cssCode);
        let replaced = false;

        for (const [fileName, chunk] of Object.entries(bundle)) {
          if (
            fileName.endsWith('.js') &&
            chunk.type === 'chunk' &&
            typeof chunk.code === 'string'
          ) {
            // Prepend the CSS variable declaration at the start of the bundle
            if (!chunk.code.includes('var __INLINED_WIDGET_CSS__')) {
              chunk.code = `var __INLINED_WIDGET_CSS__ = ${inlinedCss};\n${chunk.code}`;
              replaced = true;
              console.log(`[shadowCssPlugin] Inlined CSS into ${fileName}`);
            } else if (chunk.code.includes(PLACEHOLDER)) {
              // Legacy: Replace placeholder if it exists
              chunk.code = chunk.code.replace(
                new RegExp(PLACEHOLDER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
                inlinedCss
              );
              replaced = true;
              console.log(`[shadowCssPlugin] Replaced placeholder in ${fileName}`);
            }
          }
        }

        if (!replaced) {
          console.warn('[shadowCssPlugin] Could not inject CSS - no suitable chunk found');
        }
      }
    },
  };
}
