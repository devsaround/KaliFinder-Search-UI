import type { Plugin } from 'vite';

/**
 * Vite plugin to bundle processed CSS as an exportable string for Shadow DOM injection
 * This ensures Tailwind CSS is fully processed before being embedded
 */
export function shadowCssPlugin(): Plugin {
  let cssCode = '';
  const PLACEHOLDER = '__INLINED_WIDGET_CSS_PLACEHOLDER__';
  let sawRawCss = false; // track index.css imported as ?raw or ?inline

  return {
    name: 'vite-plugin-shadow-css',
    enforce: 'post', // Run after other plugins process CSS so TS/JS stays valid

    // Augment the CSS import with a placeholder constant
    transform(code, id) {
      // Trigger on our bootstrap entry in TSX/JS outputs (check normalized path)
      const normalizedId = id.replace(/\\/g, '/');
      // Detect raw/inline CSS import so we can skip asset warnings later
      if (/index\.css\?(?:inline|raw)$/.test(normalizedId)) {
        sawRawCss = true;
      }
      if (
        normalizedId.includes('bootstrap') &&
        (id.endsWith('.tsx') || id.endsWith('.jsx') || id.endsWith('.js') || id.endsWith('.ts'))
      ) {
        // Inject a global variable declaration that will be replaced with actual CSS
        const cssImportRe = /(import\s+['"](?:\.\.\/|\.\/)?index\.css(?:\?(?:inline|raw))?['"];?)/g;
        if (cssImportRe.test(code)) {
          const injected = `\n// Injected by shadowCssPlugin - will be replaced with actual CSS during build\nvar __INLINED_WIDGET_CSS__ = ${JSON.stringify(PLACEHOLDER)};`;
          const replaced = code.replace(cssImportRe, `$1${injected}`);
          return { code: replaced, map: null };
        }
      }
      return null;
    },

    // Capture CSS generated by Tailwind and other processors
    generateBundle(options, bundle) {
      let cssAssetFound = false;

      // Find CSS assets in the bundle
      for (const [fileName, chunk] of Object.entries(bundle)) {
        if (fileName.endsWith('.css') && chunk.type === 'asset') {
          cssCode = chunk.source.toString();
          console.log(`[shadowCssPlugin] Captured ${cssCode.length} bytes of CSS from ${fileName}`);
          // Remove the CSS file from output since we'll inline it
          delete bundle[fileName];
          cssAssetFound = true;
        }
      }

      // If no CSS assets and we didn't see ?raw, warn; otherwise log and continue
      if (!cssAssetFound && !sawRawCss) {
        console.warn(
          '[shadowCssPlugin] No CSS found in bundle - styles may not work in Shadow DOM'
        );
        return;
      } else if (sawRawCss) {
        console.log('[shadowCssPlugin] CSS inlined via ?raw â€” skipping asset warning');
      }

      // Only try to inline if we found CSS assets
      if (cssCode) {
        // Inline CSS into the UMD bundle by replacing the placeholder
        const inlinedCss = JSON.stringify(cssCode);
        let replaced = false;

        for (const [fileName, chunk] of Object.entries(bundle)) {
          if (
            fileName.endsWith('.js') &&
            chunk.type === 'chunk' &&
            typeof chunk.code === 'string'
          ) {
            // Replace the placeholder with actual CSS
            if (chunk.code.includes(PLACEHOLDER)) {
              chunk.code = chunk.code.replace(
                new RegExp(PLACEHOLDER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'),
                inlinedCss
              );
              replaced = true;
              console.log(`[shadowCssPlugin] Inlined CSS into ${fileName}`);
            }
            // Also support direct __WIDGET_CSS__ assignment if it exists
            if (
              chunk.code.includes('__WIDGET_CSS__') &&
              chunk.code.includes('__INLINED_WIDGET_CSS__')
            ) {
              // Update the variable assignment to use the actual CSS
              chunk.code = chunk.code.replace(
                /var __WIDGET_CSS__ = \(typeof __INLINED_WIDGET_CSS__ !== 'undefined' \? __INLINED_WIDGET_CSS__ : undefined\);/g,
                `var __WIDGET_CSS__ = ${inlinedCss};`
              );
              replaced = true;
            }
          }
        }

        if (!replaced) {
          console.warn(
            '[shadowCssPlugin] Placeholder not found in bundle - CSS may not be injected'
          );
        }
      }
    },
  };
}
